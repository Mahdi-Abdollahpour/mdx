
# Mahdi Abdollahpour (mahdi.abdollahpour@unibo.it)
# 2025


# SPDX-FileCopyrightText: Copyright (c) 2024 NVIDIA CORPORATION & AFFILIATES. All rights reserved.
# SPDX-License-Identifier: LicenseRef-NvidiaProprietary
#
# NVIDIA CORPORATION, its affiliates and licensors retain all intellectual
# property and proprietary rights in and to this material, related
# documentation and any modifications thereto. Any use, reproduction,
# disclosure or distribution of this material and related documentation
# without an express license agreement from NVIDIA CORPORATION or
# its affiliates is strictly prohibited.

[global]
label = 'mdx_var_mcs_BSL_LMMSE_16x4_mcs0' # all relevant files such as weights will use this label
ebno = True # activate rate-adjusted SNR

[system]
n_size_bwp = 4
num_rx_antennas = 16
mcs_index = [9, 14, 19]
mcs_table = 1
carrier_frequency = 2140000000.0
subcarrier_spacing = 30000.0
n_start_grid = 0
slot_number = 0
frame_number = 0
cyclic_prefix = 'normal'
precoding = 'codebook'
n_cell_id = 1
tpmi = 2
symbol_allocation = [0, 14]
num_antenna_ports = 2
dmrs_mapping_type = "A"
dmrs_config_type = 1
dmrs_type_a_position = 2
dmrs_additional_position = 1
dmrs_length = 1
dmrs_nid = [[1, 1], [1, 1]]
n_scid = 1
num_cdm_groups_without_data = 2
verbose = False
dmrs_port_sets = [[0], [1], [2], [3]]
n_rntis = [1, 1]
n_ids = [1, 1]

[baseline]
demapping_type = 'maxlog'
num_bp_iter = 20
cn_type = 'boxplus'
# For large num_prbs (>100), a low reduced complexity
# LMMSE estimator is used where LMMSE is only performed over the
# lmmse_num_prbs PRBS
# if set to -1, the splitting parameters are calculated via an heurisitic
# the target of the heuristic is to find the best split such that
# the resulting LMMSE is done over at least 20 PRBs
lmmse_num_prbs = -1 # n_size_bwp must be multiple of this constant

[neural_receiver]
num_nrx_iter = 1 # defines number of cgnn_it stages
num_nrx_iter_eval = 1 # iterations used for evaluation; must be <= num_nrx_iter
d_s = 3
num_units_init = [8,8,8,8] #last filter size should be a multiply of num_rx_ant
# element 0: 3--> one skip mul mat per resBlock | 2--> separated real & imag skip multiplier | 1--> one skip mul matrix for both real, imag parts | 0--> scaler mul
# element 1: 2--> matrix input noise mul in LMMSE       | 1--> scaler noise mul | 0--> no noise mul
# element 2: 2--> matrix output noise mul in LMMSE      | 1--> scaler noise mul | 0--> no noise mul
# element 3: 1--> skip mul mat tilde, 0--> no skip mul tilde
# element 4: 0--> lmmse_init same as the rest           | >0--> only scaler mul
# element 5: 0--> mcs specific mul at lmmse out err     | 1--> no mcs specific mul
# element 6: 1--> snr loss weighting                    | 0 --> no loss weighting
# element 7: 1--> mcs loss weighting                    | 0 --> no mcs loss weighting

# element num = [[0], [1], [2], [3], [4], [5], [6], [7], [1], [1], [1], [1],[1], [1], [1], [1]] # number of neurons of state aggregation MLP (each list entry defines one layer)
num_units_agg = [[3], [1], [1], [0], [0], [0], [1], [0], [1], [1], [1], [1],[1], [1], [1], [1]] # number of neurons of state aggregation MLP (each list entry defines one layer)
num_units_state = [[5, 5], [5, 5], [5, 5], [5, 5], [5, 5], [5, 5], [5, 5], [5, 5]] # num filter kernels for stage update CNN (each list entry defines one layer)
num_units_readout = [128]  # number of neurons of state aggregation MLP (each list entry defines one layer)
arch = "res_blocks2"  # CHNN Input Layer Type: single, 3adj, all_shared, all_distinct, res_blocks, res_blocks2 (2 skip conn.)
max_num_tx = 4 # max number of active DMRS ports
min_num_tx = 1 # only relevant during training for random user sampling
initial_chest = "ls" # "None" deactivates initial LS estimation
custom_constellation = False # activates trainable transmitter
mask_pilots = False # mask DMRS positions for e2e experiments

# quantization and other custom layer types
layer_type_dense = "dense"
layer_type_conv = "sepconv" # or "conv"        
layer_type_readout = "dense"
nrx_dtype = tf.float32

[Positional Encoding]
pe_d = 8 # embeding length of sin PE
pe_n = 100 # param sin PE
pe_type = 3# 0:NRX default | 1:sin coding | 2:PRB coding | 3:NRX default + PRB coding

[transfer_learning]
# transfer_weights_path = '../weights/mdx_res_blocks2_new_weights.h5'
transfer_weights_path = '../weights/mdx_res_blocks2_var_mcs_it1_weights.h5'
# lr_mul = [0.001, 1, 1, 1, 1] # lr multiplier for transfered weights

[training]
# each entry of the training schedule denotes
# [number of SGD iterations, learning rate, batch_size, trainable_const.]
training_schedule = {
    "num_iter": [20e1, 60e1, 20e1],
    "learning_rate": [0.001, 0.001, 0.001],
    "batch_size": [64, 64, 64],
    "train_tx": [False, False,False],
    "min_training_snr_db": [[0., 0., 0., 0., 0., 0.,0.,0.,0.,0.,0.,0.],[0., .5, 1., 1.5, 2., 2.5, 3., 3.5, 3.5, 3.5, 4.,4.] ,[0., .5, 1.5, 2., 2.5, 2.5, 3., 3.5, 3.5, 3.5, 4.,4.]], # 1 / 2 active UEs, is Eb/No [dB] if ebno==True
    "max_training_snr_db": [[10., 12., 12.5, 13., 14., 15., 15., 15., 15., 15.,15.,15.],[10., 12., 12., 13., 13.,13.5, 14., 14.5, 15., 15., 15., 15.],[10., 12., 12., 13., 13.,13.5, 14., 14.5, 16., 17., 18., 18.]], # 1 / 2 active UEs, is Eb/No [dB] if ebno==True
    "double_readout": [True, True, True], # use additional MSE loss on h_hat
    "apply_multiloss": [True, True, True],
    "weighting_double_readout": [[.01,0.0], [.01,0.0], [.01,0.0]], # MSE h weight
    "cgnn_steps": [-1, -1, -1]} # num cgnn steps to be repeated for any i<=num_it.| 0: random cgnn_steps| -1 : only num_nrx_iter, 



num_iter_train_save = 100
num_iter_step = 100
max_ut_velocity = 34.
min_ut_velocity = 0.
channel_norm = False
cfo_offset_ppm = 0.0 # randomly sampled in [-cfo_offset_ppm, cfo_offset_ppm]
# UMi
channel_type = 'UMi'
eval_ebno_db_arr = [1.0, 4.0, 4.0]  # EbNo to evaluate model for each MCS during training
# TDL (for two UEs)
#channel_type = 'DoubleTDLlow'
xla = True # Activate XLA for the training loop
tfrecord_filename = "na" # only relevant if training is done with a dataset

[evaluation]
# the following parameters are used during evaluation
snr_db_eval_min = -15
snr_db_eval_max = 11
snr_db_eval_stepsize = 1
max_ut_velocity_eval = 34
min_ut_velocity_eval = 0
cfo_offset_ppm_eval = 0.0
tfrecord_filename_eval = "na"
channel_type_eval = "UMi" 
# channel_type_eval = "DoubleTDLlow" # 2 Users
#channel_type_eval = 'TDL-B100' # 1 User
channel_norm_eval = False
# n_size_bwp_eval = 132
n_size_bwp_eval = 22
batch_size_eval = 30
batch_size_eval_small = 3 # for k-best-based baselines
batch_size_cov = 128
